import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';
import { Document, Packer, Paragraph, TextRun, Table, TableCell, TableRow, HeadingLevel, AlignmentType } from 'docx';
import PptxGenJS from 'pptxgenjs';
import html2canvas from 'html2canvas';

export interface ExportOptions {
  format: 'pdf' | 'excel' | 'word' | 'powerpoint' | 'html';
  title: string;
  includeCharts?: boolean;
  includeImages?: boolean;
  pageOrientation?: 'portrait' | 'landscape';
  fontSize?: number;
  margins?: {
    top: number;
    bottom: number;
    left: number;
    right: number;
  };
}

export interface ReportSection {
  id: string;
  title: string;
  type: string;
  content?: string;
  data?: any;
  ai_generated?: boolean;
}

export interface ExportData {
  title: string;
  description?: string;
  sections: ReportSection[];
  metadata?: {
    generatedAt: string;
    generatedBy: string;
    version: string;
  };
}

export class ReportExportService {
  private static instance: ReportExportService;

  static getInstance(): ReportExportService {
    if (!ReportExportService.instance) {
      ReportExportService.instance = new ReportExportService();
    }
    return ReportExportService.instance;
  }

  async exportReport(data: ExportData, options: ExportOptions): Promise<Blob> {
    switch (options.format) {
      case 'pdf':
        return this.exportToPDF(data, options);
      case 'excel':
        return this.exportToExcel(data, options);
      case 'word':
        return this.exportToWord(data, options);
      case 'powerpoint':
        return this.exportToPowerPoint(data, options);
      case 'html':
        return this.exportToHTML(data, options);
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }
  }

  private async exportToPDF(data: ExportData, options: ExportOptions): Promise<Blob> {
    const pdf = new jsPDF({
      orientation: options.pageOrientation || 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    let yPosition = margin;

    // Add title
    pdf.setFontSize(20);
    pdf.text(data.title, margin, yPosition);
    yPosition += 15;

    // Add description
    if (data.description) {
      pdf.setFontSize(12);
      const descriptionLines = pdf.splitTextToSize(data.description, pageWidth - 2 * margin);
      pdf.text(descriptionLines, margin, yPosition);
      yPosition += descriptionLines.length * 5 + 10;
    }

    // Add metadata
    if (data.metadata) {
      pdf.setFontSize(10);
      pdf.text(`Generated: ${data.metadata.generatedAt}`, margin, yPosition);
      pdf.text(`By: ${data.metadata.generatedBy}`, margin, yPosition + 5);
      yPosition += 15;
    }

    // Add sections
    for (const section of data.sections) {
      // Check if we need a new page
      if (yPosition > pageHeight - 40) {
        pdf.addPage();
        yPosition = margin;
      }

      // Section title
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text(section.title, margin, yPosition);
      yPosition += 10;

      // Section content
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(11);

      if (section.content) {
        const contentLines = pdf.splitTextToSize(section.content, pageWidth - 2 * margin);
        pdf.text(contentLines, margin, yPosition);
        yPosition += contentLines.length * 5 + 10;
      }

      // Handle different section types
      if (section.data && options.includeCharts) {
        yPosition = await this.addChartToPDF(pdf, section, yPosition, margin, pageWidth);
      }

      yPosition += 10;
    }

    return pdf.output('blob');
  }

  private async exportToExcel(data: ExportData, options: ExportOptions): Promise<Blob> {
    const workbook = XLSX.utils.book_new();

    // Add title sheet
    const titleData = [
      ['Report Title', data.title],
      ['Generated At', data.metadata?.generatedAt || ''],
      ['Generated By', data.metadata?.generatedBy || ''],
      ['Description', data.description || '']
    ];

    const titleSheet = XLSX.utils.aoa_to_sheet(titleData);
    XLSX.utils.book_append_sheet(workbook, titleSheet, 'Title');

    // Add sections as separate sheets
    for (const section of data.sections) {
      let sheetData: any[][] = [];

      // Section header
      sheetData.push([section.title]);
      sheetData.push(['']); // Empty row

      // Section content
      if (section.content) {
        sheetData.push(['Content', section.content]);
        sheetData.push(['']); // Empty row
      }

      // Handle different data types
      if (section.data) {
        switch (section.type) {
          case 'table':
            if (Array.isArray(section.data)) {
              sheetData = sheetData.concat(this.convertTableDataToExcel(section.data));
            }
            break;
          case 'kpi':
            if (Array.isArray(section.data)) {
              sheetData.push(['KPI', 'Value', 'Change', 'Trend']);
              section.data.forEach((kpi: any) => {
                sheetData.push([kpi.label, kpi.value, kpi.change, kpi.trend]);
              });
            }
            break;
          case 'finding':
            if (Array.isArray(section.data)) {
              sheetData.push(['Title', 'Severity', 'Status', 'Description', 'Due Date']);
              section.data.forEach((finding: any) => {
                sheetData.push([
                  finding.title,
                  finding.severity,
                  finding.status,
                  finding.description,
                  finding.dueDate
                ]);
              });
            }
            break;
          case 'risk':
            if (Array.isArray(section.data)) {
              sheetData.push(['Title', 'Level', 'Impact', 'Likelihood', 'Score', 'Status']);
              section.data.forEach((risk: any) => {
                sheetData.push([
                  risk.title,
                  risk.level,
                  risk.impact,
                  risk.likelihood,
                  risk.score,
                  risk.status
                ]);
              });
            }
            break;
        }
      }

      const sheet = XLSX.utils.aoa_to_sheet(sheetData);
      XLSX.utils.book_append_sheet(workbook, sheet, section.title.substring(0, 31)); // Excel sheet names limited to 31 chars
    }

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    return new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  }

  private async exportToWord(data: ExportData, options: ExportOptions): Promise<Blob> {
    const doc = new Document({
      sections: [{
        properties: {},
        children: [
          // Title
          new Paragraph({
            text: data.title,
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
          }),

          // Description
          ...(data.description ? [
            new Paragraph({
              text: data.description,
              alignment: AlignmentType.LEFT,
            }),
            new Paragraph({ text: '' }) // Empty line
          ] : []),

          // Metadata
          ...(data.metadata ? [
            new Paragraph({
              text: `Generated: ${data.metadata.generatedAt}`,
              alignment: AlignmentType.LEFT,
            }),
            new Paragraph({
              text: `By: ${data.metadata.generatedBy}`,
              alignment: AlignmentType.LEFT,
            }),
            new Paragraph({ text: '' })
          ] : []),

          // Sections
          ...data.sections.flatMap(section => [
            new Paragraph({
              text: section.title,
              heading: HeadingLevel.HEADING_1,
            }),

            ...(section.content ? [
              new Paragraph({
                text: section.content,
              }),
              new Paragraph({ text: '' })
            ] : []),

            // Handle different section types
            ...(section.data ? (() => {
              const table = this.createWordTableForSection(section);
              return table ? [table] : [];
            })() : [])
          ].filter(Boolean))
        ].filter(Boolean)
      }]
    });

    const buffer = await Packer.toBuffer(doc);
    const uint8Array = new Uint8Array(buffer);
    return new Blob([uint8Array], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
  }

  private async exportToPowerPoint(data: ExportData, options: ExportOptions): Promise<Blob> {
    const pptx = new PptxGenJS();

    // Add title slide
    const titleSlide = pptx.addSlide();
    titleSlide.addText(data.title, {
      x: 0.5,
      y: 0.5,
      w: 9,
      h: 1,
      fontSize: 32,
      bold: true,
      align: 'center'
    });

    if (data.description) {
      titleSlide.addText(data.description, {
        x: 0.5,
        y: 1.8,
        w: 9,
        h: 1,
        fontSize: 18,
        align: 'center'
      });
    }

    // Add content slides
    for (const section of data.sections) {
      const slide = pptx.addSlide();

      // Section title
      slide.addText(section.title, {
        x: 0.5,
        y: 0.3,
        w: 9,
        h: 0.8,
        fontSize: 24,
        bold: true
      });

      let yPosition = 1.2;

      // Section content
      if (section.content && yPosition < 6) {
        const contentHeight = Math.min(2, (section.content.length / 100) * 0.5);
        slide.addText(section.content, {
          x: 0.5,
          y: yPosition,
          w: 9,
          h: contentHeight,
          fontSize: 14
        });
        yPosition += contentHeight + 0.3;
      }

      // Handle different section types
      if (section.data && options.includeCharts) {
        yPosition = this.addDataToPowerPointSlide(slide, section, yPosition);
      }
    }

    // Generate PowerPoint file
    const pptxBuffer = await pptx.write({ outputType: 'blob' });
    return pptxBuffer as Blob;
  }

  private async exportToHTML(data: ExportData, options: ExportOptions): Promise<Blob> {
    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${data.title}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .header {
            text-align: center;
            border-bottom: 2px solid #333;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        .section {
            margin-bottom: 30px;
        }
        .section-title {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #ddd;
        }
        .metadata {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
        }
        .content {
            margin-bottom: 15px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .kpi-item {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
        }
        .kpi-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .kpi-label {
            font-size: 14px;
            color: #666;
        }
        .ai-generated {
            background-color: #f0f8ff;
            border-left: 4px solid #0066cc;
            padding: 10px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>${data.title}</h1>
        ${data.description ? `<p>${data.description}</p>` : ''}
        ${data.metadata ? `
        <div class="metadata">
            <p>Generated: ${data.metadata.generatedAt}</p>
            <p>By: ${data.metadata.generatedBy}</p>
        </div>
        ` : ''}
    </div>

    ${data.sections.map(section => `
    <div class="section">
        <h2 class="section-title">${section.title}</h2>
        ${section.ai_generated ? `<div class="ai-generated">âœ¨ AI Generated Content</div>` : ''}
        ${section.content ? `<div class="content">${section.content.replace(/\n/g, '<br>')}</div>` : ''}

        ${section.data ? this.convertSectionDataToHTML(section) : ''}
    </div>
    `).join('')}
</body>
</html>`;

    return new Blob([html], { type: 'text/html' });
  }

  private async addChartToPDF(pdf: jsPDF, section: ReportSection, yPosition: number, margin: number, pageWidth: number): Promise<number> {
    // This would implement chart rendering to PDF
    // For now, just add a placeholder
    pdf.setFontSize(10);
    pdf.text(`[Chart: ${section.title}]`, margin, yPosition);
    return yPosition + 10;
  }

  private convertTableDataToExcel(data: any[]): any[][] {
    if (data.length === 0) return [];

    const headers = Object.keys(data[0]);
    const rows = data.map(item =>
      headers.map(header => item[header])
    );

    return [headers, ...rows];
  }

  private createWordTableForSection(section: ReportSection): Paragraph | null {
    if (!section.data || !Array.isArray(section.data)) return null;

    const table = new Table({
      rows: [
        new TableRow({
          children: Object.keys(section.data[0] || {}).map(header =>
            new TableCell({
              children: [new Paragraph(header)],
            })
          ),
        }),
        ...section.data.map(row =>
          new TableRow({
            children: Object.values(row).map(value =>
              new TableCell({
                children: [new Paragraph(String(value))],
              })
            ),
          })
        ),
      ],
    });

    return new Paragraph({
      children: [table],
    });
  }

  private addDataToPowerPointSlide(slide: any, section: ReportSection, yPosition: number): number {
    if (!section.data) return yPosition;

    // Add data visualization based on section type
    switch (section.type) {
      case 'table':
        if (Array.isArray(section.data)) {
          // Add table to PowerPoint
          const headers = Object.keys(section.data[0] || {});
          const rows = section.data.map(item =>
            headers.map(header => String(item[header]))
          );

          slide.addTable([headers, ...rows], {
            x: 0.5,
            y: yPosition,
            w: 9,
            colW: headers.map(() => 9 / headers.length),
          });
          yPosition += 2;
        }
        break;
      case 'kpi':
        if (Array.isArray(section.data)) {
          section.data.forEach((kpi: any, index: number) => {
            const x = 0.5 + (index % 3) * 3;
            const y = yPosition + Math.floor(index / 3) * 1.5;

            slide.addText(`${kpi.label}: ${kpi.value}`, {
              x,
              y,
              w: 2.8,
              h: 0.8,
              fontSize: 14,
              bold: true
            });
          });
          yPosition += Math.ceil(section.data.length / 3) * 1.5;
        }
        break;
    }

    return yPosition;
  }

  private convertSectionDataToHTML(section: ReportSection): string {
    if (!section.data) return '';

    switch (section.type) {
      case 'table':
        if (Array.isArray(section.data)) {
          const headers = Object.keys(section.data[0] || {});
          return `
<table>
    <thead>
        <tr>
            ${headers.map(h => `<th>${h}</th>`).join('')}
        </tr>
    </thead>
    <tbody>
        ${section.data.map(row =>
          `<tr>${headers.map(h => `<td>${row[h]}</td>`).join('')}</tr>`
        ).join('')}
    </tbody>
</table>`;
        }
        break;

      case 'kpi':
        if (Array.isArray(section.data)) {
          return `
<div class="kpi-grid">
    ${section.data.map(kpi => `
    <div class="kpi-item">
        <div class="kpi-value">${kpi.value}</div>
        <div class="kpi-label">${kpi.label}</div>
        ${kpi.change ? `<div>Change: ${kpi.change}%</div>` : ''}
    </div>
    `).join('')}
</div>`;
        }
        break;

      case 'finding':
      case 'risk':
      case 'control':
        if (Array.isArray(section.data)) {
          return `<ul>${section.data.map(item =>
            `<li><strong>${item.title}</strong>: ${item.description || item.status}</li>`
          ).join('')}</ul>`;
        }
        break;
    }

    return '';
  }
}

// Export singleton instance
export const reportExportService = ReportExportService.getInstance();